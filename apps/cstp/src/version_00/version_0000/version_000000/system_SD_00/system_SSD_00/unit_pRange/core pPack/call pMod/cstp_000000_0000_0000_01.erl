%%%-------------------------------------------------------------------
%% @doc
%%  https://cessor.org
%%  Cessor Information Systems, CIS
%%  CIS License v0.1.0
%%  Cessor Service Transaction Protocol
%%  Version Crown-Block index = 0
%%  Version Serial Domain = 0
%%  Version Serial Number = 0
%%  Service Domain = 0;         System service domain
%%  Service Sub-Domain = 0;     System service sub-domain
%%  Procedure Range = 0;        Unit Procedure Packages Range
%%  Procedure Package = 0;      Core Procedure Package
%%  Process Module = 1;         Call Process Module
%% @end
%%%-------------------------------------------------------------------
-module(cstp_000000_0000_0000_01).

-export([compose/2]).
-export([compute/2]).

-import(cstp_ft, [ft/2]).

%%%%%%%%%%%%%%%
%%   EXPORT  %%
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%
%%   Compose CSTX  %%
%%%%%%%%%%%%%%%%%%%%%
%%
%% compose({Order, TX}, STATE)-> Result
%%  Order = list of tuples, [Process | Rest]
%%          Process = tuple of numbers, {PM, Processor_ref}
%%                    PM = number, >=0 && <256, process module
%%                    Processor_ref = number, >=0 && <256, process ID
%%          Rest = list of tuples, [ Parameters ]
%%  TX = binary, recursive composed TX
%%  STATE = map, state of caller has to be compatible with order resources
%%  Result =
%%      {ok,TX_}
%%          TX_ = binary, recursive composed TX
%%                      
%%      {error,  Reason}
%%          Generated by Fault Tolerance
%%            ft(Issuer, Fault) 
%%              Issuer = compose
%%              Fault =
%%                {error, [order]}, order format is unavail+able
%% INFO:
%%      Compose a cessor cervice transaction, CSTX from an order list
%%      This module composes orders with Version {CBI=0, VSD=0, VSN=0}
%%      This module composes orders with Service {SD=0, SSD=0}
%%      This module composes orders with Procedure {PR=0, PP=0}
%%      This module composes orders with Process Module PM=1
%%      Processor reference pRef=0; is reserved for Services STATUS Processor
%%      Compose caller can be every processes id, PID
%%
compose({[{_module=1, _ref=0}|Order], TX}, STATE) ->
    processor_ref0({compose, Order, TX}, STATE);
compose(Order, _STATE) ->
    ft(_Issuer={?MODULE, compose}, _Fault={error, [order, Order]}).
%%%%%%%%%%%%%%%%%%%%%
%%   Compute CSTX  %%
%%%%%%%%%%%%%%%%%%%%%
%%
%% compute(TX, STATE)-> Result
%%  TX = binary, << Process, Rest >>
%%          Process = binary, << Processor_ref >>
%%                    Processor_ref = number, >=0 && <256, process ID
%%          Rest = binary, << Parameters >>
%%  STATE = map, state of caller has to be compatible with the resources needed to compute TX
%%  Result =
%%      {ok,Call_back}
%%          Call_back = term
%%                      
%%      {error,  Reason}
%%          Reason = generated by Fault Tolerance
%%            ft(Issuer, Fault) 
%%              Issuer = compute
%%              Fault =
%%                {error, [permission]}, Caller has no permission
%% INFO:
%%      Compute a cessor cervice transaction, CSTX
%%      Call module has to be called by core generic server
%%
compute(TX, STATE)->
    case whereis(core) == self() of
        true ->
            compute(parse, TX, STATE);
        false ->
            ft(_Issuer={?MODULE, compute}, _Fault={error, [permission]})
    end.

%%%%%%%%%%%%%%%%%
%%   INTERNAL  %%
%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Parse Processor Reference Information %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% compute({parse, TX}, STATE)-> Result
%%  TX = binary, << Process, Rest >>
%%          Process = binary, << Processor_ref >>
%%                    Processor_ref = number, >=0 && <256, process ID
%%          Rest = binary, << Parameters >>
%%  STATE = map, state of caller has to be compatible with the resources needed to compute TX
%%  Result =
%%      Result of processor_ref*k/2
%%                      
%%      {error,  Reason}
%%          Reason = generated by Fault Tolerance
%%            ft(Issuer, Fault) 
%%              Issuer = compute
%%              Fault =
%%                {error, [parse]}, Tx format is not available
%% INFO:
%%      Compute a cessor cervice transaction, CSTX
%%      Parse Processor References to compute
%%      Processor reference pRef=0; is reserved for System Services STATUS Processor
%%
compute(parse, <<0, TX_/binary>>, STATE)->
    processor_ref0({compute, TX_}, STATE);
compute(parse, _TX, _STATE) ->
    ft(_Issuer={?MODULE, compute}, _Fault={error, [parse]}).

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Module Processors  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   System STATUS Processor  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% processor_ref0({compose, TX}, _)-> Result
%%  TX = binary, recursive composed TX
%%  
%%  Result =
%%      {ok,TX_}
%%          TX_ = binary, recursive composed TX
%% INFO:
%%      Compose CSTX for processor_ref0
%%      System Services STATUS Processor
%%      A set of tasks to integrate state with System Services status.
%%      Request caller has to be one of the System Services
%%  
processor_ref0({compose, [STATUS], TX}, _STATE)
    when is_binary(STATUS)->
    {ok, <<TX/binary, 0, STATUS/binary>>};
%%
%% processor_ref0({compute, TX}, _)-> Result
%%  TX = binary, <<STATUS>>
%%  
%%  Result =
%%      Result of processor_ref0({update_status, Service}, STATE)
%%      {error,  Reason}
%%          Reason = generated by Fault Tolerance
%%            ft(Issuer, Fault) 
%%              Issuer = processor_ref0
%%              Fault =
%%                {error, [permission]}, caller has no permission
%% INFO:
%%      Compute CSTX
%%      Check permission of processor caller
%%
processor_ref0({compute, STATUS}, STATE)->
    Services = maps:get(service, STATE),
    Caller = maps:get(caller, STATE),
    Fun =
        fun(Component={_,PID,_}, _)
            when PID==Caller->
                Component;
            (_,Component)->
                Component
        end,
    case lists:foldl(Fun, {}, Services) of
        {Name, PID, _} ->
            processor_ref0({update_status, {Name, PID, STATUS}}, STATE);
        _->
            %%  Perhaps core is under attack
            ft(_Issuer={?MODULE, processor_ref0}, _Fault={error, [permission]})
    end;
%%
%% processor_ref0({update_status, Service}, _)-> Result
%%  Service = record, {Name, PID, STATUS}
%%          Name = atom, key, name of service
%%          PID = pid, pid of service
%%          STATUS = binary, new status of service
%%  
%%  Result =
%%      {ok, _reply=ok, STATE}
%%          STATE = map, updated state of core generic server
%%      {error,  Reason}
%%          Reason = generated by Fault Tolerance
%%            ft(Issuer, Fault) 
%%              Issuer = processor_ref0
%%              Fault =
%%                {error, [status]}, status is unavailable
%% INFO:
%%      Update STATUS of a service
%%      Update service information
%%      Asynchronous call to update core STATUS
%%
processor_ref0({update_status, {Name, _PID, STATUS}}, STATE)->
    %%  STATUS unset, init, boot, ready
    STATUS_atom =
        case STATUS of
            <<"INIT">> ->
                init;
            <<"BOOT">> ->
                boot;
            _->
                []
        end,
    case is_atom(STATUS_atom) of
        true ->
            % Update service information
            Services = maps:get(service, STATE),
            Services_new = lists:keyreplace(Name, 1, Services, {Name, _PID, STATUS_atom}),
            STATE_services = maps:update(service, Services_new, STATE),

            %   Asynchronous call to update core STATUS
            TX = [
                _version={0,0,0},
                _service={0,0},     %system services
                _procedure={0,0},   %unit pRange, Core pPack
                _process={0,2}      %state pMod, status pRef
            ],
            {ok, CSTX} = cstp:compose(TX, STATE_services),
            Process_refs = maps:get(proc_ref, STATE),
            Ref = make_ref(),
            gen_server:cast(self(), {Ref, CSTX}),
            New_process_ref= Process_refs++[Ref],
            STATE_proc_ref = maps:update(proc_ref, New_process_ref, STATE_services),

            {ok, _reply=ok, STATE_proc_ref};
        false ->
            ft(_Issuer={?MODULE, processor_ref0}, _Fault={error, [status]})
    end;
%%
%% processor_ref0(_, _)-> Result
%%  Result =
%%      {error,  Reason}
%%          Reason = generated by Fault Tolerance
%%            ft(Issuer, Fault) 
%%              Issuer = processor_ref0
%%              Fault =
%%                {error, [tx]}, TX format is unavailable
%% INFO:
%%      Computation is failed because of unavailable arguments
%%
processor_ref0(A,_) ->
    ft(_Issuer={?MODULE, processor_ref0}, _Fault={error, [tx, A]}).
